{"name": "BDD Language", "log": "Stardate - 2/14/2022\n\nToday marks the day that a new adventure will start. I am freshly graduated with my bachelors degree in Computer Science and am on the hunt for employment, but in the meantime (and probably while I have a job), I have a new project: creating my own personal programming language. For those of you unaware, suffice it to say that this is not a trivial objective. The purpose of this first log is to detail some of the initial requirements I am setting for this new language, but first I would like to say that the goal of this project is primarily to prove to myself that I can create a language. Again, this is not an easy thing to do and I have almost no knowledge on the subject. I had wanted to take an elective on compilers during college, but it never worked out with my schedule meaning this project will be entirely self taught.\n\nAnother thing I am setting in stone now is that this is a project that I intend to finish. Those that know me personally or have perused my GitHub repos will know that I have a tendancy to get an idea, start a project, then never finish it (or in the process of working on it, have another idea, start a new project, then not finish either of them). Therefore this project will only be complete when I have a working prototype, or by admission of utter defeat. I am recording this log in order to keep track of my thoughts, keep myself on track and potentially as a reference to other people who intend to make the same journey as I am.\n\nI intend to create a language that is the ultimate combination of the things I like about the 3 languages I use the most:\n1) Python\n2) Java\n3) C++\n\nIf you know your languages, then you know that these are all within the same approximate family:\n* Procedural, Functional, and Object Oriented\n* Syntax is heavily C based\n* Generic (i.e., not field specific like R, Matlab, etc)\n\nIn terms of the \"level\" of these languages, however, they are obviously all over the place: Python is very high, C++ is low, and Java is somewhere in the middle. They also differ in runtime, with C++ being compiled, Python is interpreted, and Java once again somewhere in the middle doing a bit of both. I will need to think about how my language will be run as they all have their pros and cons. but I am leaning towards something similar to Jave if possible.\n\nThe first steps for this project will primarily be education and planning. Like I said before, I have little experience with creating languages or writing compilers. I at least know how to define grammars, but I will need to learn a lot more about how languages are actually constructed.", "children": [{"name": "Books", "log": "To start off with, I am reading: \"Compiler Construction\" by William M. Waite and Herhard Goos.\nFree PDF: https://www.cs.cmu.edu/~aplatzer/course/Compilers/waitegoos.pdf\nThis text is a bit dated by now (1995), but it seems to have a strong base in the theory and should prove useful.\nI have given up on this one. Far too theoretical.\n(372 pages)\n\nNext:\n  Compilers: Principles, Techniques, and Tools. (Second Edition). Aho, Lam, Sethi, and Ullman. ISBN: 0-321-48681-1\n  (2007) looks... thorough, probably a useful one (1038 pages)\n\n  \"Introduction to Compilers and Language Design\" by Douglas Thain\n  Free PDF: https://www3.nd.edu/~dthain/compilerbook/\n  More modern (2020) and potentially a bit more implementation focused (247 pages)\n  \n  Programming Language Pragmatics. (Third Edition). Michael L. Scott. ISBN: 978-0-12-374514-9.\n  (2009) Looks about the same as the last one (940 pages)", "children": [{"name": "New Log", "log": "", "children": [], "date": ""}], "date": ""}, {"name": "The Forebearers", "log": "Herein lies my thoughts on the languages that I am using as references.\n\nPrimarily this will be C++, Java, and Python but I may branch out with thoughts on other languages that I have used in the past.", "children": [{"name": "C++", "log": "This is the big one. The one every knows (and fears). C++ is the father of all modern Object-Oriented-Programming. As such it is also... old. C++ is still widely used and remains the goto for anything requiring a precise touch and getting as low-level as possible without going to assembly.\n\n\n\nThings I don't like about C++:\n* Header files\n* Memory leaks\n* cout\n\n\n\nThings I like about C++:\n* Explicit call by value or by ref/pointer\n* SPEEEED\n*", "children": [], "date": ""}, {"name": "Java", "log": "I have had a good amount of experience with Java. Primarily through my college studies since it was the language of choice for a lot of my classes as it was by far the easiest for the professor's to test with minimal issue. This is a good example of one of Java's key selling points: portability. Java is a bit of a mutant language, being both compiled and interpreted. But, it allows easy portability between operating systems and CPU architectures without needing to distribute the source or build it yourself.\n\nNow, as for the language itself, it is very C-like. The first thing one might notice is that all Java code must be contained in a class definition. Even the main function(s) must be contained in a class. I can only assume they chose to do this as it provides a mechanism similar to C++ namespaces, but I would also say that this was already handled via the handy-dandy Java package system. As such, I find it a bit cumbersome when defining entirely static functions. Java also has the requirement that code filenames must be the same as the class it is defining. This has to do with the package system and how java finds the definitions via the filename. One thing I like about Java is its package system. Packages are 1) explicitly specified in the file itself, and 2) organized into a directory structure.\n\nJava also has the unusual feature of allowing multiple main functions. Every class you define can have it's own main, but you can still only run one at a time (although I guess you could call main manually from another class). When running a Java program, you specify the classname as the program name and that defines which main is run. This is an interesting feature (similar to how you can specify any file as \"main\" in python), but I am unsure as to how useful it actually is.\n\n\nThings I like about Java:\n* Automatic garbage collection, although it can contribute to slower code as this is handled by the Java interpreter\n* Reference semantics, although I like having the option of the amount of control a C++ pointer has\n* explicit package names and little argument when trying to access code parent packages\n\tAlso running Java programs in different folders doesn't change the package lookup path\n* PORTABILITY\n* JAR files. Really just zip files, but you can put whatever you want and access it at runtime. Useful for embedding things (like, for instance SQL queries) as separate files without needing them as strings in you rcode\n\n\nThings I don't like about Java:\n* Lack of function pointers\n\tThese kinda exist now in the latest versions via lambda interfaces, but they seem hacky\n* Lack of default func arguments\n\tThe canonical way to handle this is to use function overloading, but I find it leads to less readable code.\n* The primitive type wrapper classes and needing to use them in class templates. Also those wrappers have wierd properties that can't be replicated in client code, i.e. automatic conversion to and from primitive types. \n* Having to specify public and private for every function.", "children": [], "date": ""}, {"name": "Python", "log": "Over the past year, I have written a lot of code in Python (too much Python) and despite how much power a very high-level lang gives you, I still find it to be lacking in some ways. In particular, I dislike it for much the same reasons that I find JavaScript to be a terrible language: weakly-typed variables. While an argument can be made that typeless variables and arguments improve code readability and reduces typing (the kind you do with your fingers), in the end I find it harms the developer more-so when they cannot easily discern the type of an object without manually checking it (which in the nd adds more code). I find this especially annoying when using 3rd party libraries and they either:\n  1) Don't use type hints\n  2) did complicated things with packages and whatnot, breaking any IDE's \t\t\tability to find the types\n  3) Poorly document their API and expected argument types\n  \nNo to mention that IDE's will struggle with any static error checking and also have a tendancy to tell me an argument is the wrong type or even that it doesn't exist, but then the code still runs as expected.\n\nA list of other things I dislike about Python\n* lack of true public/private class members\n* lack of true abstract classes/interfaces\n* lack of true enums\n* lack of true const values\n* manually specifying \"self\" for EVERY class variable and method declaration and usage\n* lack of true multithreading\n* the whole no curly brackets thing is meh and causes more issues when autoformatting if nothing else\n* why is True and False capitalized?\n* lack of true multi-line comments, like... why?\n* \"elif\" ...need I say more \n\nDespite this, there are still quite a lot of things I DO like about python\n* simplicity in creating new projects/package structure\n* list comprehensions (obviously... who doesn't abuse these?)\n* simple operator/keyword overloading\n* keyword only arguments\n* functions as first-class objects\n* lists, dicts, and sets as standard language constructs\n* the freakin print func is always available and not \"System.out.println()\" or \"\"cout << nonsense\"\n* F strings\n* array slicing\n* ternary if-else using keywords\n* __init__.py allowing setup code when importing a package", "children": [], "date": ""}], "date": ""}, {"name": "Proper Planning", "log": "\nTHE BIG THINGS:\n* Strongly Typed\n* True multithreading support\n* Clean interface for embedding in C++\n* Python-like iteration\n* Java-like packages\n* Cpp-like threads", "children": [], "date": ""}, {"name": "Spitballing", "log": "Random thoughts on random ideas", "children": [{"name": "What's in the name", "log": "Those of you who know me, know that names are very important to me. It has to be the just right combination of coolness, memorability, and potentially puns.\n\nCurrent name ideas\n  Wyvern, .wy - sadly already taken, but I've been saving this one for a while\n  \n  Jumble\n    Jumbalaya, .jm - bit wordy, but memorable. On theme for the jumble of inspiration languages\n    Hydra, .hy - good, kinda like Python, on theme again for more than one head\n    Amalgam, .am - mouthful?\n    Cerberus, .cb\n    \n    \n  Brain Dead Dev \n    Skeleton/Skelly, .sk\n    LichScript, .ls \n    Salamander, .sl\n    Mimic, .mc\n    Spectre, .sp\n    \n    \n  Misc\n    WolfScript, .ws - NCSU themed I guess, memorable. Could really add Script to the end of any word\n    Atlas, .at - greek names always cool", "children": [], "date": ""}, {"name": "Garbage Collection", "log": "All objects act as smart pointers\nSimple to calculate\n\nIssues:\n\tcycles are an issue, need a separate GC check\n\nCould just fall back to C++ and put that responsiblity on the programmer", "children": [], "date": ""}, {"name": "Regex", "log": "Be nice to have regex as a language construct\n\nHave a specific delimiter to specify a string as regex so that we can eliminate the need for escape sequences\nObviously needs to be something uncommon in regex, or potentially a multi-char sequence\n<\"asdf\">\n\nhave regex as a primitive type?\n\nAt a minimum, I know I want to have a way to represent raw strings using a special delimiter.\n\nPerl has a raw regex syntax?", "children": [], "date": ""}, {"name": "Annotations", "log": "a", "children": [], "date": ""}, {"name": "Built-In Datatypes", "log": "I definitely want Lists, Dicts, and Sets to be built in.\nAllow users to specify different implementations?\nI.e. \nLinked List vs Array\nLList[str] mylist = ['asdf'];\nmyList = L['asdf'];\nmyList = A['asdf'];", "children": [], "date": ""}, {"name": "Nested Enums", "log": "enum ASDF\n{\n  A,\n  B,\n  enum Inner\n  {\n     C,\n     D\n  }\n}\n\nASDF.A\nASDF.B\nASDF.Inner.C\n\nCan declare a var as ASDF or specifically Inner", "children": [], "date": ""}, {"name": "Allow kebab case", "log": "Want to be able to use kebab case in names, underscores suck\n\nthis-name = asdf.potat()", "children": [], "date": ""}], "date": ""}, {"name": "The Dev Log", "log": "Herein shall lie logs written over the course of development.", "children": [{"name": "4/5/22 The REAL Beginning", "log": "It has been almost two months since I began my research into basic compiler construction and language design. I gave up halfway on trying to read \"Compiler Construction\" (1996, Waite and Goos) as it was a bit outdated and I had a hard time understanding a lot of the examples as they were primarily using older languages like COBOL, and Fortran. This text was also very theory heavy, and while I know a bit of set theory, a lot of it went over my head and wasn't very useful (and very hard to parse in the first place). Instead, I read \"Introduction to Compilers and Language Design\" (2020 Thain) which was a much better experience as it was more implementation based and less focused on describing the various types of grammers in mathematical notation.\n\nBut now, having a (very) basic knowledge of language construction, I feel empowered enough to create the world's best programming language and no-one can stop me.\nMore importantly, though, I have finally decided on a name:\n# SIGIL\nWhy? Becuase it's cool, obviously. And it's simple, easy to remember, and fits the theme of BDD pretty nicely. Also, most importantly, it's not already taken by an exisiting language. \n\nThe first thing I should do next is start figuring out Sigil's grammer. I have ideas on some basic things, but I haven't nailed down the specifics yet. I will also need to start working on a formal definition of the language, which means I need to start writing some BNF to describe it's structure.", "children": [], "date": ""}, {"name": "4/7/22 First steps", "log": "I have begun to write some code samples of what I want the language to look like. In doing so I have discovered some things that I want to try to implement.\n\nFirst of all, typing. I knew from the beginning that Sigil would be a strongly typed language, and I wouldn't change my mind about that. But, I appreciate the cleanliness of python allowing me to simply create a variable with a name and not needing to write out a potentially long and complicated type specification like in Java or C++. Therefore, I want to make typing optional for variables. Essentially, we would be assuming that you are using the \"auto\" keyword from c++ which leaves it up to the compiler to infer the type unless you have explicitly specified one. However, this only applies to variables. Function arguments must be typed to ensure that arguments can be type checked at compile time. I may also be able to make the type optional for func arguments if a default value is given, unless null is given as the default, in which case the type must still be specified. I think that function return types will always be required, although I guess I could try to infer from the return statements but that seems more difficult than checking every return type to the specified one.\nSince function return types will always be known at compile time, all variable types can be inferred at compile time making typing errors visible at compile time. In other words, Sigil is strongly typed without needing every variable type to be declared.\n\nI was also planning on making lists be a language construct, and I think the way I'm going to do it is that Lists can only have one datatype contained in them so that it is easy to infer the type.\nI think I will also want to implement Tuples, which can have more than one datatype, but the exact number of each must be known at compile time.\nI might have the type templating be with square brackets like python's typing package, but if this interferes with the array operator I may just user corner brackets.\nList[int] vs List<int>\nList[int] x = [0, 1, 2, 3, 4];\nTuple[int, String, Person] x = (0, \"potato\", Person(\"Jim));\n\nI also like the readability of python's branch/loop statements in that they don't require parentheses around the expressions.\nif(x == 0) {}\nvs\nif x == 0:\nI do not, however, like python's lack of brackets. Creating code blocks using only indentation is... not great. Therefore, I want to combine the two approaches:\nif x == 0 {}\n\nIF_STMT = \"if\" EXPR BLOCK\n\nFor simple ifs, you can omit the brackets for a \"then\" and an expression plus additionally an else.\n\nIF_STMT = \"if\" EXPR \"then\" EXPR \"else\" EXPR \";\"\n\n\nI want to apply this to all control statements, ifs, fors, whiles, etc. \n\nI also want to bring in python-like for-in loops\nfor x in list {}\nx's type can be inferred from the list\n\nI also want to use this syntax for c++ style for loops, but using keywords\nfor x = 0 while x < 25 then ++x {}\nNot sure if I like \"then\" as the keyword there, but it is at least it doesn't add a new keyword. \"do\" doesn't quite work there at least.\n\nWHILE_STMT = \"while\" EXPR BLOCK\nDO_WHILE_STMT = \"do\" BLOCK \"while\" EXPR \";\"\n\nAs for classes, I think they will be pretty similar to C++, just with some extra access modifiers. First of all, I like that in c++ I can use a label to define multiple things under the same access modifier (unlike java, where you have to specify public/private/.. for every declaration). That being said, I think it can be improved. Specifically, I want to use brackets to surround everything in an access group, instead of just being in the same group until we hit another label.\npublic\n{\n  int x;\n  static float z;\n}\n\nBut, I think I won't allow functions to be defined in these blocks (because of the new accesses I will define momentarily) meaning they will still have to explicitly state their access.\n\nNow, as for the access modifiers, I have come up with 5.\npublic: The same as normal, can be freely accessed from outside the class, as well as subclasses\nprivate: The same as normal, can be accessed ONLY from within this class, i.e. not including subclasses\nshared: The same as \"protected\" in c++, i.e. accessed only by this class and subclasses\nreadonly: Can be freely accessed from inside this class, but acts in a \"const\" manner from outside\ncommon: Can be freely accessed from inside this class and subclasses, but is readonly from outside\n\tNot sure about the keyword for this one\n\nI need to sit down and clearly define \"const\" as it has strange side-effects in c++\n\nFunctions\n\nClass constructors will be similar to c++ and java, i.e. they are functions with no return type and named the same as the class.\n\nClasses will otherwise act exactly the same as java classes. Classes methods will have an implicit \"this\" reference, as opposed to python/JS which explicity specify \"self\" as the first argument.", "children": [], "date": ""}, {"name": "4/22/22 PEEBNF", "log": "While I was beginning to write out some early descriptions of Sigil's grammer, I had a fantastic idea to have my compiler be able to read in some EBNF rules and use that to parse the language.\nNow, there are programs out there that already do this, so called \"Compiler Compilers\" (Lex, YACC, and Bison to name a few) that can be used to create simple languages in and of themselves, but can also be manipulated into spitting out syntax trees and the like. But, of course, it would be too constricting to try and use one of these for Sigil and, frankly, too easy.\n\nTherefor, I have created my own version of EBNF, PEEBNF! The \"Poorly-Extended Extended Backus-Naur Form.\" This is so far basically the same as EBNF, although without the fancy things like alternation and repetition, which may come into play at a later date, but most likely will just be implemented with some form of preprocessing.\n\nSo, while implementing said EBNF parser in C++, I quickly realized that this was something I could do very easily using Python's regex module. This then lead down the rabbit hole of me trying to learn how to embed python into C, which isn't too bad in itself, but I had a hell of a time getting it to compile. \nThis was mainly due to the fact that:\n1) I was building C++ on Windows which is always annoying\n2) I was using the MingW compiler and the Python .lib files were compiled for MSVC\n\nBut of course, I was using CMake, so everything was fine in the end as it could generate VS projects for me.\n\nI don't know yet whether the final version of the Sigil compiler will have python in it. It would seem more efficient to have a separate program read in my EBNF and compile it to something easy to read in and have the Sigil compiler use that. I do however, like the idea of embedding Python into this project becuase that is just fun.\n\nIn order for Sigil's grammer to be able to parse everything correctly, it needs to be converted into an equivalent LR(1) grammer (for reasons that I don't fully understand, but has to do with Chomsky's Heirarchy).\n\nIn order to create a parser for an LR(1) grammer we need to generate the so called \"First\" and \"Follow\" sets for the grammer using the EBNF. There are plenty of descriptions of this algorithm in various resources, but I was unable to find any \"good\" pseudo-code so I am going to start writing some for any algorithms I encounter.", "children": [], "date": ""}], "date": ""}], "date": ""}