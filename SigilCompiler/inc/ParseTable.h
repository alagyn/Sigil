#pragma once
/*******
This file was generated by ParseTableGen, do not edit
2023-06-30 16:11:21.946344
*******/
#include <vector>
#include <string>
#include <map>

#include <boost/regex.hpp>

namespace sigil {

enum class Action
{
    Error,
    Shift,
    Reduce,
    Goto,
    Accept
};

enum class Symbol {
    lit_string,
    program,
    definition,
    func_definition,
    arg_def_list,
    rest_of_args,
    statement,
    assignment,
    optional_type,
    expression,
    semicolon,
    open_curly,
    close_curly,
    open_paren,
    close_paren,
    open_square_bracket,
    close_square_bracket,
    comma,
    equals_sign,
    plus_sign,
    minus_sign,
    star_sign,
    kw_for,
    kw_in,
    kw_if,
    kw_class,
    kw_private,
    lit_integer,
    lit_float,
    double_quote_string,
    single_quote_string,
    name,
    __EOF__
};

const std::map<Symbol, std::string> TERMINAL_LOOKUP = {
    {Symbol::semicolon, "semicolon"},
    {Symbol::open_curly, "open_curly"},
    {Symbol::close_curly, "close_curly"},
    {Symbol::open_paren, "open_paren"},
    {Symbol::close_paren, "close_paren"},
    {Symbol::open_square_bracket, "open_square_bracket"},
    {Symbol::close_square_bracket, "close_square_bracket"},
    {Symbol::comma, "comma"},
    {Symbol::equals_sign, "equals_sign"},
    {Symbol::plus_sign, "plus_sign"},
    {Symbol::minus_sign, "minus_sign"},
    {Symbol::star_sign, "star_sign"},
    {Symbol::kw_for, "kw_for"},
    {Symbol::kw_in, "kw_in"},
    {Symbol::kw_if, "kw_if"},
    {Symbol::kw_class, "kw_class"},
    {Symbol::kw_private, "kw_private"},
    {Symbol::lit_integer, "lit_integer"},
    {Symbol::lit_float, "lit_float"},
    {Symbol::double_quote_string, "double_quote_string"},
    {Symbol::single_quote_string, "single_quote_string"},
    {Symbol::name, "name"},
    {Symbol::__EOF__, "__EOF__"}};

typedef struct
{
public:
    Symbol id;
    boost::regex re;
} Terminal;

const std::vector<Terminal> TERMINALS = {
    {Symbol::semicolon, boost::regex(";")},
    {Symbol::open_curly, boost::regex("{")},
    {Symbol::close_curly, boost::regex("}")},
    {Symbol::open_paren, boost::regex("\\(")},
    {Symbol::close_paren, boost::regex("\\)")},
    {Symbol::open_square_bracket, boost::regex("\\[")},
    {Symbol::close_square_bracket, boost::regex("\\]")},
    {Symbol::comma, boost::regex(",")},
    {Symbol::equals_sign, boost::regex("=")},
    {Symbol::plus_sign, boost::regex("\\+")},
    {Symbol::minus_sign, boost::regex("-")},
    {Symbol::star_sign, boost::regex("\\*")},
    {Symbol::kw_for, boost::regex("for")},
    {Symbol::kw_in, boost::regex("in")},
    {Symbol::kw_if, boost::regex("if")},
    {Symbol::kw_class, boost::regex("class")},
    {Symbol::kw_private, boost::regex("private")},
    {Symbol::lit_integer, boost::regex("[1-9]\\d*")},
    {Symbol::lit_float, boost::regex("\\d+.\\d+")},
    {Symbol::double_quote_string, boost::regex("\"([^\"]|(\\\\\"))*\"")},
    {Symbol::single_quote_string, boost::regex("'([^']|(\\\\'))*'")},
    {Symbol::name, boost::regex("[a-zA-Z][a-zA-Z0-9_]*")}
};

typedef struct
{
    Action action;
    int state;
} ParseAction;

const ParseAction PARSE_TABLE[3][33] = {
{ {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Shift, 1}, {Action::Shift, 2}, {Action::Error, 0}, {Action::Accept, 0} },
{ {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Reduce, 0} },
{ {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Error, 0}, {Action::Reduce, 0} }
};
}
