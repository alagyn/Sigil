import re
from typing import List
from argparse import ArgumentParser
from datetime import datetime
import os

import parse_table_gen.preprocessing as preprocess
from parse_table_gen.ebnf_grammer import parse_grammer, Grammer
from parse_table_gen.first_and_follow import FirstAndFollow
from parse_table_gen.lalr1_automata import LALR1Automata, ParseTable
from parse_table_gen.consts import END


def parse_ebnf_file(filename: str) -> Grammer:
    cleanLines = preprocess.read_and_clean(filename)
    combinedLines = preprocess.combine_lines(cleanLines)
    del cleanLines

    return parse_grammer(combinedLines)


def main():
    parser = ArgumentParser()
    parser.add_argument("grammer_file")
    parser.add_argument("output_file")

    args = parser.parse_args()

    grammer_file = args.grammer_file

    if not os.path.exists(grammer_file):
        print("Cannot open grammer file:", grammer_file)

    grammer = parse_ebnf_file(grammer_file)
    ff = FirstAndFollow(grammer)
    lalr = LALR1Automata(grammer, ff)
    table = ParseTable(lalr)

    with open(args.output_file, mode='w') as f:
        f.write(
            "#pragma once\n"
            "/*******\n"
            "This file was generated by ParseTableGen, do not edit\n"
            f"{datetime.now()}\n"
            "*******/\n"
            "#include <vector>\n"
            "#include <string>\n"
            "#include <map>\n"
            "\n"
            "#include <boost/regex.hpp>\n"
            "\n"
            "namespace sigil {\n"
            "\n"
            "// Error\n"
            "constexpr char E = 0;\n"
            "// Shift\n"
            "constexpr char S = 1;\n"
            "// Reduce\n"
            "constexpr char R = 2;\n"
            "// Goto\n"
            "constexpr char G = 3;\n"
            "// Accept\n"
            "constexpr char A = 4;\n"
            "\n"
            'enum class Symbol {\n'
        )

        for idx, terminal in enumerate(table.symbolList):
            f.write(f"    {terminal}")
            if idx < len(table.symbolList) - 1:
                f.write(",")
            f.write("\n")
        f.write("};\n\n")  # End enum Symbol

        f.write("const std::vector<std::string> SYMBOL_LOOKUP = {\n")
        for idx, symbol in enumerate(table.symbolList):
            f.write(f'   "{symbol}"')
            if idx < len(table.symbolList) - 1:
                f.write(',')
            f.write("\n")
        f.write("};\n\n")  # End Symbol name list

        f.write(
            "typedef struct\n"
            "{\n"
            "public:\n"
            "    Symbol id;\n"
            "    boost::regex re;\n"
            "} Terminal;\n"
            "\n"
            "const std::vector<Terminal> TERMINALS = {\n"
        )

        for idx, terminal in enumerate(grammer.terminalList):
            regex = re.sub(r"\\", r"\\\\", terminal[1])
            regex = re.sub(r'"', r'\\"', regex)
            f.write(f'    {{Symbol::{terminal[0]}, boost::regex("{regex}")}}')
            if idx < len(grammer.terminalList) - 1:
                f.write(",")
            f.write("\n")
        f.write("};\n\n")  # End Terminal list

        f.write(
            "typedef struct {\n"
            "    // The number of states to pop\n"
            "    short numPops;\n"
            "    // The ID of the nonterminal reduced to\n"
            "    short nontermID;\n"
            "} Reduction;\n"
            "// idx == the rule, retrieved from the parse table\n"
            "\n"
            "const std::vector<Reduction> REDUCTIONS = {\n"
        )
        for idx, rule in enumerate(grammer.rules):
            f.write(f'{{{len(rule.symbols)} , {table.symbolIDs[rule.nonterm]}}}')
            if idx < len(grammer.rules) + 1:
                f.write(',')
            f.write('\n')
        f.write("};\n")  # End REDUCTIONS

        f.write(
            "typedef struct\n"
            "{\n"
            "    char action = E;\n"
            "    short state = 0;\n"
            "} ParseAction;\n"
            "\n"
            f"constexpr unsigned TABLE_ROWS = {len(table.table)};\n"
            f"constexpr unsigned TABLE_COLS = {len(table.table[0])};\n"
            f"const ParseAction PARSE_TABLE[{len(table.table)}][{len(table.table[0])}] = {{\n"
        )

        for rowIdx, row in enumerate(table.table):
            f.write("{ ")
            for idx, action in enumerate(row):
                if action[0] != ParseTable.ERROR:
                    f.write(f"{{{action[0]}, {action[1]}}}")
                else:
                    f.write('{}')
                if idx < len(row) - 1:
                    f.write(", ")

            f.write(" }")  # End Parse Row
            if rowIdx < len(table.table) - 1:
                f.write(",")
            f.write("\n")

        f.write("};\n")  # End Parse table

        f.write("}\n")  # End namespace Sigil


if __name__ == '__main__':
    main()
