import re
from typing import List
from argparse import ArgumentParser

import parse_table_gen.preprocessing as preprocess
from parse_table_gen.ebnf_grammer import parse_grammer, Grammer
from parse_table_gen.first_and_follow import FirstAndFollow
from parse_table_gen.lalr1_automata import LALR1Automata, ParseTable
from parse_table_gen.consts import END


def parse_ebnf_file(filename: str) -> Grammer:
    cleanLines = preprocess.read_and_clean(filename)
    combinedLines = preprocess.combine_lines(cleanLines)
    del cleanLines

    return parse_grammer(combinedLines)


def main():
    parser = ArgumentParser()
    parser.add_argument("grammer_file")
    parser.add_argument("output_file")

    args = parser.parse_args()
    grammer = parse_ebnf_file(args.grammer_file)
    ff = FirstAndFollow(grammer)
    lalr = LALR1Automata(grammer, ff)
    table = ParseTable(lalr)

    with open(args.output_file, mode='w') as f:
        f.write(
            "#pragma once\n"
            "/*******\nThis file was generated by ParseTableGen, do not edit\n*******/\n"
            "#include <vector>\n"
            "#include <string>\n"
            "#include <map>\n"
            "\n"
            "#include <boost/regex.hpp>\n"
            "\n"
            "namespace sigil {\n"
            "\n"
            "enum class Action\n"
            "{\n"
            "    Error,\n"
            "    Shift,\n"
            "    Reduce,\n"
            "    Goto,\n"
            "    Accept\n"
            "};\n"
            "\n"
            'enum class Symbol {\n'
        )

        for idx, terminal in enumerate(table.symbolList):
            f.write(f"    {terminal}")
            if idx < len(table.symbolList) - 1:
                f.write(",")
            f.write("\n")
        f.write("};\n\n")  # End enum Symbol

        f.write("const std::map<Symbol, std::string> TERMINAL_LOOKUP = {\n")
        for idx, terminal in enumerate(grammer.terminalList):
            f.write(f'    {{Symbol::{terminal[0]}, "{terminal[0]}"}},\n')
        f.write(f'    {{Symbol::{END}, "{END}"}}')
        f.write("};\n\n")  # End Terminal name map

        f.write(
            "typedef struct\n"
            "{\n"
            "public:\n"
            "    Symbol id;\n"
            "    boost::regex re;\n"
            "} Terminal;\n"
            "\n"
            "const std::vector<Terminal> TERMINALS = {\n"
        )

        for idx, terminal in enumerate(grammer.terminalList):
            regex = re.sub(r"\\", r"\\\\", terminal[1])
            f.write(f'    {{Symbol::{terminal[0]}, boost::regex("{regex}")}}')
            if idx < len(grammer.terminalList) - 1:
                f.write(",")
            f.write("\n")
        f.write("};\n\n")  # End Terminal list

        f.write(
            "typedef struct\n"
            "{\n"
            "    Action action;\n"
            "    int state;\n"
            "} ParseAction;\n"
            "\n"
            f"const ParseAction PARSE_TABLE[{len(table.table)}][{len(table.table[0])}] = {{\n"
        )

        for rowIdx, row in enumerate(table.table):
            f.write("{ ")
            for idx, action in enumerate(row):
                if action[0] == ParseTable.ACCEPT:
                    actEnum = "Accept"
                elif action[0] == ParseTable.GOTO:
                    actEnum = "Goto"
                elif action[0] == ParseTable.REDUCE:
                    actEnum = "Reduce"
                elif action[0] == ParseTable.SHIFT:
                    actEnum = "Shift"
                else:
                    actEnum = "Error"
                f.write(f"{{Action::{actEnum}, {action[1]}}}")
                if idx < len(row) - 1:
                    f.write(", ")

            f.write(" }")  # End Parse Row
            if rowIdx < len(table.table) - 1:
                f.write(",")
            f.write("\n")

        f.write("};\n")  # End Parse table

        f.write("}\n")  # End namespace Sigil


if __name__ == '__main__':
    main()
