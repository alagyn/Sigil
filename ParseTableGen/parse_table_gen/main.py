import re
from typing import List
from argparse import ArgumentParser
from datetime import datetime
import os

import parse_table_gen.preprocessing as preprocess
from parse_table_gen.ebnf_grammer import parse_grammer, Grammer
from parse_table_gen.first_and_follow import FirstAndFollow
from parse_table_gen.lalr1_automata import LALR1Automata, ParseTable, Action
from parse_table_gen.consts import END


def parse_ebnf_file(filename: str) -> Grammer:
    cleanLines = preprocess.read_and_clean(filename)
    combinedLines = preprocess.combine_lines(cleanLines)
    del cleanLines

    return parse_grammer(combinedLines)


def main():
    parser = ArgumentParser()
    parser.add_argument("grammer_file")
    parser.add_argument("output_file")

    args = parser.parse_args()

    grammer_file = args.grammer_file

    if not os.path.exists(grammer_file):
        print("Cannot open grammer file:", grammer_file)
        exit(1)

    try:
        grammer = parse_ebnf_file(grammer_file)
    except Exception as err:
        print("Cannot parse grammer:", err)
        exit(1)

    ff = FirstAndFollow(grammer)

    try:
        lalr = LALR1Automata(grammer, ff)
    except Exception as err:
        print("Cannot compute LALR(1) automata:", err)
        exit(1)

    try:
        table = ParseTable(lalr)
    except Exception as err:
        print("Cannot compute parse table:", err)
        exit(1)

    with open(args.output_file, mode='w') as f:
        f.write(
            "/*******\n"
            "This file was generated by ParseTableGen, do not edit\n"
            f"{datetime.now()}\n"
            "*******/\n"
            "#include <inc/parseTable.h>\n"
            "#include <vector>\n"
            "#include <string>\n"
            "#include <map>\n"
            "\n"
            "#include <boost/regex.hpp>\n"
            "\n"
            "namespace sigil {\n"
            "namespace parseTable {\n"
            "\n"
            'enum class Symbol {\n'
        )

        for idx, terminal in enumerate(table.symbolList):
            f.write(f"    {terminal}")
            if idx < len(table.symbolList) - 1:
                f.write(",")
            f.write("\n")
        f.write("};\n\n")  # End enum Symbol

        f.write("const std::vector<std::string> SYMBOL_LOOKUP = {\n")
        for idx, symbol in enumerate(table.symbolList):
            f.write(f'   "{symbol}"')
            if idx < len(table.symbolList) - 1:
                f.write(',')
            f.write("\n")
        f.write("};\n\n")  # End Symbol name list

        f.write("const std::vector<Terminal> TERMINALS = {\n")

        for idx, terminal in enumerate(grammer.terminalList):
            regex = re.sub(r"\\", r"\\\\", terminal[1])
            regex = re.sub(r'"', r'\\"', regex)
            f.write(f'    {{Symbol::{terminal[0]}, boost::regex("{regex}")}}')
            if idx < len(grammer.terminalList) - 1:
                f.write(",")
            f.write("\n")
        f.write("};\n\n")  # End Terminal list

        f.write("const std::vector<Reduction> REDUCTIONS = {\n")
        for idx, rule in enumerate(grammer.rules):
            f.write(f'{{{len(rule.symbols)} , {table.symbolIDs[rule.nonterm]}}}')
            if idx < len(grammer.rules) + 1:
                f.write(',')
            f.write('\n')
        f.write("};\n")  # End REDUCTIONS

        tableRows = len(table.table)
        tableCols = len(table.table[0])

        f.write(
            f"constexpr unsigned TABLE_ROWS = {tableRows};\n"
            f"constexpr unsigned TABLE_COLS = {tableCols};\n"
            f"const ParseAction PARSE_TABLE[{tableRows}][{tableCols}] = {{\n"
        )

        for rowIdx, row in enumerate(table.table):
            f.write("{ ")
            for idx, action in enumerate(row):
                if action.action != Action.E:
                    f.write(f"{{{action.action}, {action.state}}}")
                else:
                    f.write('{}')
                if idx < len(row) - 1:
                    f.write(", ")

            f.write(" }")  # End Parse Row
            if rowIdx < len(table.table) - 1:
                f.write(",")
            f.write("\n")

        f.write(
            "};\n"  # End Parse table
            "const std::string& symbolLookup(Symbol symbol)\n"
            "{\n"
            "    return symbolLookup(static_cast<unsigned>(symbol));\n"
            "}\n"
            "const ParseAction& getAction(unsigned state, Symbol symbol)\n"
            "{\n"
            "    return getAction(state, static_cast<unsigned>(symbol));\n"
            "}\n"
            "const std::vector<Terminal>& getTerminals()\n"
            "{\n"
            "    return TERMINALS;\n"
            "}\n"
            "const Terminal& getTerminal(Symbol symbol)\n"
            "{\n"
            "    return TERMINALS.at(static_cast<unsigned>(symbol));\n"
            "}\n"
            "const std::string& symbolLookup(unsigned symbol)\n"
            "{\n"
            "    return SYMBOL_LOOKUP.at(symbol);\n"
            "}\n"
            "const Reduction& getReduction(short rule)\n"
            "{\n"
            "    return REDUCTIONS.at(rule);\n"
            "}\n"
            "const unsigned numRows()\n"
            "{\n"
            "    return TABLE_ROWS;\n"
            "}\n"
            "const unsigned numCols()\n"
            "{\n"
            "    return TABLE_COLS;\n"
            "}\n"
            "const ParseAction& getAction(unsigned state, unsigned symbol)\n"
            "{\n"
            "    return PARSE_TABLE[state][symbol];\n"
            "}\n"
            "Symbol eof()\n"
            "{\n"
            f"    return Symbol::{END};\n"
            "}\n"
        )

        f.write("}\n"  # End namespace parseTable
                "}\n"  # End namespace Sigil
                )


if __name__ == '__main__':
    main()
