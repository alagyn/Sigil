# The starting rule, must be first
program = definitions;
definitions
    = definition
    | definition definitions
    ;

# Char declarations
SEMICOLON = ";";
OPEN_CURLY = "{";
CLOSE_CURLY = "}";
OPEN_PAREN = "\(";
CLOSE_PAREN = "\)";
OPEN_SQUARE = "\[";
CLOSE_SQUARE = "\]";
COMMA = ",";
COLON = ":";

# Operators
OP_EQUALS = "=";
OP_PLUS = "\+";
OP_MINUS = "-";
OP_STAR = "\*";
OP_SLASH = "/";
OP_POW = "\*\*";
OP_DOT = '\.';
OP_LTEQ = "<=";
OP_GTEQ = ">=";
OP_LT = "<";
OP_GT = ">";

# Keywords
KW_DO = "do";
KW_ELSE = "else";
KW_FOR = "for";
KW_IN = "in";
KW_IF = "if";
KW_NOT = "not";
KW_RETURN = "return";
KW_TO = "to";
KW_WHILE = "while";
KW_ABSTRACT = "abstract";
KW_ENUM = "enum";
KW_CLASS = "class";

# Literals
LIT_INT = '[1-9]\d*';
LIT_FLOAT = "\d+.\d+"; # TODO scientific notation?

DOUBLE_QUOTE_STR = '"([^"]|(\\"))*"';
SINGLE_QUOTE_STR = "'([^']|(\\'))*'";
lit_string
    = DOUBLE_QUOTE_STR
    | SINGLE_QUOTE_STR
    ;

lit_list = OPEN_SQUARE args CLOSE_SQUARE;
lit_set = OPEN_CURLY args CLOSE_CURLY;
lit_map = OPEN_CURLY map_list CLOSE_CURLY;
map_list
    = map_expression
    | map_expression COMMA map_list
    ;

map_expression = expression COLON expression;

literal
    = LIT_INT
    | LIT_FLOAT
    | lit_set
    | lit_string
    | lit_list
    | lit_map
    ;

# type names
TYPE_ARRAY = "array";
TYPE_LIST = "list";
TYPE_MAP = "map";
TYPE_SET = "set";
TYPE_STR = "str";
TYPE_INT = "int";
TYPE_FLOAT = "float";

type
    = TYPE_ARRAY OP_LT type OP_GT
    | TYPE_LIST OP_LT type OP_GT
    | TYPE_MAP OP_LT type COMMA type OP_GT
    | TYPE_SET OP_LT type OP_GT
    | TYPE_STR
    | TYPE_INT
    | TYPE_FLOAT
    | NAME
    ;

# Access modifiers
ACC_PUBLIC = "public";
ACC_PRIVATE = "private";
ACC_READONLY = "readonly";
ACC_SHARED = "shared";

access_modifier
    = ACC_PUBLIC
    | ACC_PRIVATE
    | ACC_READONLY
    | ACC_SHARED
    ;

# This goes after all the builtins
NAME = "[a-zA-Z][a-zA-Z0-9_]*";

definition
    = func_definition
    | class_definition
    | enum_definition
    ;

# Generic curly bracket body
body
    = OPEN_CURLY statements CLOSE_CURLY
    | OPEN_CURLY CLOSE_CURLY # Allow for no statements without needing an epsilon
    ;

func_access
    = access_modifier
    | KW_ABSTRACT
    | EMPTY
    ;

func_definition
    = func_access type NAME OPEN_PAREN arg_definitions CLOSE_PAREN body
    | func_access type NAME OPEN_PAREN CLOSE_PAREN body
    ;

arg_definitions
    = argument
    | argument COMMA arg_definitions
    ;

argument
    = type NAME OP_EQUALS expression # TODO is expression the right thing here? The value should be evaluatable at compile time
    | type NAME
    ;

statements
    = statement
    | statement statements # Recursion
    ;

statement
    = statement_body SEMICOLON # This enforces semicolons for all simple statements
    | body # Allow arbitrary scopes
    | if_statement
    | while_statement
    | do_while_statement
    | for_statement
    ;

statement_body
    = assignment
    | return_statement
    | expression
    ;

if_statement = KW_IF expression body else_statement;
else_statement
    = KW_ELSE body
    | KW_ELSE if_statement # This will recurse for more else-ifs
    ;

while_statement = KW_WHILE expression body;
do_while_statement = KW_DO body KW_WHILE expression SEMICOLON;

for_statement
    = KW_FOR NAME KW_IN expression body
    | KW_FOR NAME KW_IN expression KW_TO expression body
    ;

return_statement = KW_RETURN expression;

assignment
    = NAME OP_EQUALS assign_expr
    | type NAME OP_EQUALS assign_expr
    ;

assign_expr
    = expression
    | expression KW_IF expression KW_ELSE expression # x = 12 if b else 15;
    ;

# Expression, defines the order of operations
expression
    = expression OP_PLUS term
    | expression OP_MINUS term
    | term
    ;
term
    = term OP_STAR factor
    | term OP_SLASH factor
    | factor
    ;
factor
    = factor OP_POW pow_term
    | pow_term
    ;

pow_term
    = OP_MINUS pow_term # Negation
    | KW_NOT pow_term
    | OPEN_PAREN expression CLOSE_PAREN
    | function_call
    | literal
    | NAME
    ;

# Functions
function_call
    = NAME OPEN_PAREN args CLOSE_PAREN
    | NAME OPEN_PAREN CLOSE_PAREN
    ;

args
    = expression
    | expression COMMA args
    ;

# Class
class_definition_access
    = ACC_PUBLIC
    | ACC_PRIVATE
    | EMPTY
    ;

class_definition
    = class_definition_access KW_CLASS NAME OPEN_PAREN NAME CLOSE_PAREN class_body
    | class_definition_access KW_CLASS NAME class_body
    ;

class_body
    = OPEN_CURLY class_statements CLOSE_CURLY
    | OPEN_CURLY CLOSE_CURLY
    ;

class_statements
    = access_modifier body # Vars must be declared in an access modifer block
    | access_modifier func_definition
    ;

# Enum
enum_definition = class_definition_access KW_ENUM NAME OPEN_CURLY enum_statements CLOSE_CURLY;
enum_statements
    = enum_statement
    | enum_statement enum_statements
    ;

enum_statement
    = NAME SEMICOLON
    | NAME OP_EQUALS LIT_INT SEMICOLON
    ;
