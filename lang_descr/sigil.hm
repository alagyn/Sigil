%include <memory>
%include <sigil/syntaxTree.h>

%return std::shared_ptr<sigil::ASTNode>

%using std
%using sigil

# The starting rule, must be first
program = definitions { return $0; };
definitions
    = definition { return $0; }
    | definition definitions
    {
        $0->next = $1;
        return $0;
    }
    ;

# Char declarations
SEMICOLON = ";";
OPEN_CURLY = "{";
CLOSE_CURLY = "}";
OPEN_PAREN = "\(";
CLOSE_PAREN = "\)";
OPEN_SQUARE = "\[";
CLOSE_SQUARE = "\]";
COMMA = ",";
COLON = ":";

# Operators
OP_EQUALS = "=";
OP_PLUS = "\+";
OP_MINUS = "-";
OP_STAR = "\*";
OP_SLASH = "/";
OP_POW = "\*\*";
OP_DOT = '\.';
OP_LTEQ = "<=";
OP_GTEQ = ">=";
OP_LT = "<";
OP_GT = ">";

# Keywords
KW_DO = "do";
KW_ELSE = "else";
KW_FOR = "for";
KW_IN = "in";
KW_IF = "if";
KW_NOT = "not";
KW_RETURN = "return";
KW_TO = "to";
KW_WHILE = "while";
KW_ABSTRACT = "abstract";
KW_STATIC = "static";
KW_ENUM = "enum";
KW_CLASS = "class";

# Literals
LIT_INT = '[1-9]\d*';
LIT_FLOAT = "\d+.\d+"; # TODO scientific notation?

DOUBLE_QUOTE_STR = '"([^"]|(\\"))*"';
SINGLE_QUOTE_STR = "'([^']|(\\'))*'";
lit_string
    = DOUBLE_QUOTE_STR { return make_shared<ExprNode>($0); }
    | SINGLE_QUOTE_STR { return make_shared<ExprNode>($0); }
    ;

lit_list
    = OPEN_SQUARE expr_list CLOSE_SQUARE
    {
        return make_shared<ExprNode>(ExprType::LitList, $expr_list, nullptr);
    }
    ;
lit_set
    = OPEN_CURLY expr_list CLOSE_CURLY
    {
        return make_shared<ExprNode>(ExprType::LitSet, $expr_list, nullptr);
    };
lit_map
    = OPEN_CURLY map_list CLOSE_CURLY
    {
        return make_shared<ExprNode>(ExprType::LitMap, $map_list, nullptr);
    }
    ;

map_list
    = map_expression { return $0; }
    | map_expression COMMA map_list
    {
        $0->next = $2;
        return $0;
    }
    ;

map_expression
    = expression COLON expression
    {
        return make_shared<ExprNode>(ExprType::LitMap, $0, $2);
    }
    ;

literal
    = LIT_INT
    {
        int val = stoi($0);
        return make_shared<ExprNode>(val);
    }
    | LIT_FLOAT
    {
        double val = stod($0);
        return make_shared<ExprNode>(val);
    }
    | lit_set { return $0; }
    | lit_string
    {
        return $0;
    }
    | lit_list { return $0; }
    | lit_map { return $0; }
    ;

# type names
TYPE_ARRAY = "array";
TYPE_LIST = "list";
TYPE_MAP = "map";
TYPE_SET = "set";
TYPE_STR = "str";
TYPE_INT = "int";
TYPE_FLOAT = "float";

type
    = TYPE_ARRAY OP_LT type OP_GT
    {
        return make_shared<DataTypeNode>(
            PrimitiveType::Array, $type
        );
    }
    | TYPE_LIST OP_LT type OP_GT
    {
        return make_shared<DataTypeNode>(
            PrimitiveType::List, $type
        );
    }
    | TYPE_MAP OP_LT type COMMA type OP_GT
    {
        return make_shared<DataTypeNode>(
            PrimitiveType::Map, $2, $4
        );
    }
    | TYPE_SET OP_LT type OP_GT
    {
        return make_shared<DataTypeNode>(
            PrimitiveType::Set, $type
        );
    }
    | TYPE_STR
    {
        return make_shared<DataTypeNode>(
            PrimitiveType::Str
        );
    }
    | TYPE_INT
    {
        return make_shared<DataTypeNode>(
            PrimitiveType::Int
        );
    }
    | TYPE_FLOAT
    {
        return make_shared<DataTypeNode>(
            PrimitiveType::Float
        );
    }
    | NAME
    {
        return make_shared<DataTypeNode>(
            $0
        );
    }
    ;

# Access modifiers
ACC_PUBLIC = "public";
ACC_PRIVATE = "private";
ACC_READONLY = "readonly";
ACC_SHARED = "shared";

access_modifier
    = ACC_PUBLIC { return make_shared<AccessModNode>(AccessMod::Public); }
    | ACC_PRIVATE { return make_shared<AccessModNode>(AccessMod::Private); }
    | ACC_READONLY { return make_shared<AccessModNode>(AccessMod::Readonly); }
    | ACC_SHARED { return make_shared<AccessModNode>(AccessMod::Shared); }
    | EMPTY { return make_shared<AccessModNode>(AccessMod::Default); }
    ;

# This goes after all the builtins
NAME = "[a-zA-Z][a-zA-Z0-9_]*";
name
    = NAME
    {
        return make_shared<ExprNode>(ExprType::Name, $0);
    }
    ;

definition
    = func_definition { return $0; }
    | class_definition { return $0; }
    | enum_definition { return $0; }
    | var_definition { return $0; }
    ;

var_definition
    = access_modifier special_mod type NAME SEMICOLON
    {
        auto accessModNode = static_pointer_cast<AccessModNode>($access_modifier);
        auto specialModNode = static_pointer_cast<SpecialModNode>($special_mod);

        auto out = make_shared<DefNode>(DefType::Var, $type, $NAME);
        out->accessMod = accessModNode->accessMod;
        out->specialMod = specialModNode->specialMod;

        return out;
    }
    ;

# Generic curly bracket body
body
    = OPEN_CURLY statements CLOSE_CURLY { return $1; }
    | OPEN_CURLY CLOSE_CURLY { return nullptr; } # Allow for no statements without needing an epsilon
    ;

special_mod
    = KW_ABSTRACT {return make_shared<SpecialModNode>(SpecialMod::Abstract);}
    | KW_STATIC {return make_shared<SpecialModNode>(SpecialMod::Static);}
    | EMPTY {return make_shared<SpecialModNode>(SpecialMod::None);}
    ;

func_definition
    = access_modifier special_mod type NAME OPEN_PAREN func_arg_definitions CLOSE_PAREN body
    {
        auto datatypeNode = make_shared<DataTypeNode>(PrimitiveType::Func, $type, $func_arg_definitions);
        auto accessModNode = static_pointer_cast<AccessModNode>($access_modifier);
        auto specialModNode = static_pointer_cast<SpecialModNode>($special_mod);

        auto out = make_shared<DefNode>(DefType::Var, datatypeNode, $NAME);
        out->accessMod = accessModNode->accessMod;
        out->specialMod = specialModNode->specialMod;
        out->body = $body;

        return out;
    }
    ;

func_arg_definitions
    = func_arg_def_list { return $0; }
    | EMPTY { return nullptr; }
    ;

func_arg_def_list
    = func_arg_def { return $0; }
    | func_arg_def COMMA func_arg_def_list
    {
        $0->next = $2;
        return $0;
    }
    ;

func_arg_def
    # TODO is expression the right thing here? The value should be evaluatable at compile time
    = type NAME OP_EQUALS expression
    {
        auto out = make_shared<DefNode>(DefType::Var, $type, $NAME);
        out->body = $expression;
        return out;
    }
    | type NAME
    {
        return make_shared<DefNode>(DefType::Var, $type, $NAME);
    }
    ;

statements
    = statement { return $0; }
    | statement statements # Recursion
    {
        $0->next = $1;
        return $0;
    }
    ;

statement
    = statement_body SEMICOLON { return $0; } # This enforces semicolons for all simple statements
    | body { return $0; } # Allow arbitrary scopes
    | if_statement { return $0; }
    | while_statement { return $0; }
    | do_while_statement { return $0; }
    | for_statement { return $0; }
    ;

statement_body
    = assignment { return $0; }
    | return_statement { return $0; }
    | expression { return $0; }
    ;

# If statements
if_statement
    = KW_IF expression body else_statement
    {
        auto out = make_shared<StmtNode>(StmtType::If);
        out->check = $expression;
        out->body = $body;
        out->elseStmt = $else_statement;

        return out;
    };
else_statement
    = KW_ELSE body { return $body; }
    | KW_ELSE if_statement # This will recurse for more else-ifs
    { return $if_statement; }
    | EMPTY { return nullptr; }
    ;

# while statements
while_statement
    = KW_WHILE expression body
    {
        auto out = make_shared<StmtNode>(StmtType::While);
        out->check = $expression;
        out->body = $body;

        return out;
    };

do_while_statement
    = KW_DO body KW_WHILE expression SEMICOLON
    {
        auto out = make_shared<StmtNode>(StmtType::DoWhile);
        out->check = $expression;
        out->body = $body;

        return out;
    };

# For statements
for_statement
    = KW_FOR name KW_IN expression body
    {
        auto out = make_shared<StmtNode>(StmtType::ForIn);
        out->decl = $name;
        out->check = $expression;
        out->body = $body;

        return out;
    }
    | KW_FOR name KW_IN expression KW_TO expression body
    {
        auto out = make_shared<StmtNode>(StmtType::ForTo);
        out->decl = $name;
        out->check = $3;
        out->update = $5;
        out->body = $body;

        return out;
    }
    ;

return_statement
    = KW_RETURN expression
    {
        auto out = make_shared<StmtNode>(StmtType::Return);
        out->body = $expression;

        return out;
    };

assignment
    = name OP_EQUALS assign_expr
    {
        auto out = make_shared<StmtNode>(StmtType::Assign);
        out->update = $name;
        out->body = $assign_expr;

        return out;
    }
    | type name OP_EQUALS assign_expr
    {
        auto out = make_shared<StmtNode>(StmtType::Assign);
        out->decl = $type;
        out->update = $name;
        out->body = $assign_expr;

        return out;
    }
    ;

assign_expr
    = expression { return $0; }
    | expression KW_IF expression KW_ELSE expression # x = 12 if b else 15;
    {
        auto out = make_shared<StmtNode>(StmtType::If);
        // True case
        out->body = $0;
        // check expression
        out->check = $2;
        // else statement
        out->elseStmt = $4;

        return out;
    }
    ;

# Expression, defines the order of operations
expression
    = expression OP_PLUS term { return make_shared<ExprNode>(ExprType::Add, $0, $2); }
    | expression OP_MINUS term { return make_shared<ExprNode>(ExprType::Sub, $0, $2); }
    | term { return $0; }
    ;
term
    = term OP_STAR factor { return make_shared<ExprNode>(ExprType::Mul, $0, $2); }
    | term OP_SLASH factor { return make_shared<ExprNode>(ExprType::Div, $0, $2); }
    | factor { return $0; }
    ;
factor
    = factor OP_POW pow_term { return make_shared<ExprNode>(ExprType::Pow, $0, $2); }
    | pow_term { return $0; }
    ;

pow_term
    # Negation
    = OP_MINUS pow_term { return make_shared<ExprNode>(ExprType::Neg, $1, nullptr); }
    # Binary negation
    | KW_NOT pow_term { return make_shared<ExprNode>(ExprType::Not, $1, nullptr); }
    # Parentheses
    | OPEN_PAREN expression CLOSE_PAREN { return $1; }
    | bottom_val { return $0; }
    ;

# The bottom layer of an expression. A single unit that can be operated on
bottom_val
    # Function calls
    = bottom_val OPEN_PAREN expr_list CLOSE_PAREN
    {
        return make_shared<ExprNode>(ExprType::Call, $bottom_val, $expr_list);
    }
    | bottom_val OPEN_PAREN CLOSE_PAREN # avoiding the EMPTY case for args since it causes issues
    {
        return make_shared<ExprNode>(ExprType::Call, $bottom_val, nullptr);
    }
    # Name resolution
    | bottom_val OP_DOT name
    {
        return make_shared<ExprNode>(ExprType::Dot, $bottom_val, $name);
    }
    # Subscript
    | bottom_val OPEN_SQUARE expression CLOSE_SQUARE
    {
        return make_shared<ExprNode>(ExprType::Subscript, $0, $2);
    }
    # comprehensions
    | comprehension { return $0; }
    # Literals
    | literal { return $0; }
    | name { return $0; }
    ;

comprehension
    # List comprehension
    = OPEN_SQUARE linear_comprehension CLOSE_SQUARE
    {
        return $1;
    }
    # Set comprehension
    | OPEN_CURLY linear_comprehension CLOSE_CURLY
    {
        return $1;
    }
    # Map comprehension
    | OPEN_CURLY expression COLON expression KW_FOR name KW_IN expression CLOSE_CURLY
    {
        // TODO
        return nullptr;
    }
    | OPEN_CURLY expression COLON expression KW_FOR name KW_IN expression KW_IF expression CLOSE_CURLY
    {
        // TODO
        return nullptr;
    }
    ;

linear_comprehension
    = expression KW_FOR name KW_IN expression
    {
        // TODO
        return nullptr;
    }
    | expression KW_FOR name KW_IN expression KW_IF expression
    {
        // TODO
        return nullptr;
    }
    ;

expr_list
    = expression
    {
        return $0;
    }
    | expression COMMA expr_list
    {
        $0->next = $2;
        return $0;
    }
    ;

# Class
class_definition
    = access_modifier KW_CLASS NAME OPEN_PAREN NAME CLOSE_PAREN class_body
    {
        auto parentType = make_shared<DataTypeNode>($4);
        auto datatype = make_shared<DataTypeNode>(PrimitiveType::Class, parentType);
        auto out = make_shared<DefNode>(DefType::Class, datatype, $2);
        out->body = $class_body;
        return out;
    }
    | access_modifier KW_CLASS NAME class_body
    {
        auto datatype = make_shared<DataTypeNode>(PrimitiveType::Class);
        auto out = make_shared<DefNode>(DefType::Class, datatype, $NAME);
        out->body = $class_body;
        return out;
    }
    ;

class_body
    = OPEN_CURLY class_statements CLOSE_CURLY { return $class_statements; }
    | OPEN_CURLY CLOSE_CURLY { return nullptr; }
    ;

var_def_list
    = var_definition { return $0; }
    | var_definition var_def_list
    {
        $0->next = $1;
        return $0;
    }
    ;

class_statements
    = class_statement { return $0; }
    | class_statement class_statements
    {
        $0->next = $1;
        return $0;
    }
    ;

class_statement
    = access_modifier special_mod OPEN_CURLY var_def_list CLOSE_CURLY # Vars must be declared in an access modifer block
    {
        auto defNode = static_pointer_cast<DefNode>($var_def_list);
        auto accessModNode = static_pointer_cast<AccessModNode>($access_modifier);
        AccessMod accessMod = accessModNode->accessMod;
        SpecialMod specialMod = SpecialMod::None;
        if($special_mod)
        {
            specialMod = static_pointer_cast<SpecialModNode>($special_mod)->specialMod;
        }

        /*
            We are going to overwrite all of the definitions access/special mods so we can
            avoid making a wrapper node for this block.

            TODO should we throw an error here? maybe just emit a warning about overwritten access
        */
        while(defNode)
        {
            if(defNode->accessMod == AccessMod::Default)
            {
                defNode->accessMod = accessMod;
            }

            if(specialMod != SpecialMod::None && defNode->specialMod == SpecialMod::None)
            {
                defNode->specialMod = specialMod;
            }

            defNode = static_pointer_cast<DefNode>(defNode->next);
        }

        return $var_def_list;
    }
    | func_definition { return $0; }
    ;

# Enum
enum_definition
    = access_modifier KW_ENUM NAME OPEN_CURLY enum_statements CLOSE_CURLY
    {
        auto accessModNode = static_pointer_cast<AccessModNode>($access_modifier);
        auto dataType = make_shared<DataTypeNode>(PrimitiveType::Enum);
        auto out = make_shared<DefNode>(DefType::Enum, dataType, $NAME);
        out->accessMod = accessModNode->accessMod;
        out->body = $enum_statements;

        return out;
    };

enum_statements
    = enum_statement { return $0; }
    | enum_statement enum_statements
    {
        $0->next = $1;
        return $0;
    }
    ;

enum_statement
    = NAME SEMICOLON
    {
        return make_shared<ExprNode>(ExprType::LitInt, $NAME);
    }
    | NAME OP_EQUALS LIT_INT SEMICOLON
    {
        auto out = make_shared<ExprNode>(ExprType::LitInt, $NAME);
        out->int_val = std::stoi($LIT_INT);
        return out;
    }
    ;
